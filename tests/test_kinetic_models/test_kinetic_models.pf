!-----------------------------------------------------------------------------------------------------------------------------------
! This file is part of ReMKiT1D.
!
! ReMKiT1D is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as 
! published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
!
! ReMKiT1D is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of 
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with ReMKiT1D. If not, see <https://www.gnu.org/licenses/>. 
!
! Copyright 2023 United Kingdom Atomic Energy Authority (stefan.mijin@ukaea.uk)
module test_kinetic_models

    use pfunit
    use god_objects       ,only: object
    use data_kinds        ,only: ik, rk
    use partition_class
    use grid_class
    use variable_list_class
    use v_space_class
    use indexing_class
    use geometry_class
    use support_types 
    use variable_container_class 
    use derivation_abstract_class
    use matrix_term_abstract_class
    use support_functions
    use mpi_controller_class
    use modelbound_data_varlike_class
    use model_surrogate_class
    use initialization_support
    use general_mat_term_class
    use kinetic_stencil_templates
    use basic_environment_wrapper
    use model_surrogate_class
    use modelbound_CRM_data_class
    use modelbound_lbc_data_class
    use fixed_ecs_transition_class
    use db_transition_class
    use inelastic_grid_data_class
    use f_scaling_derivation_class
    use variable_ecs_transition_class
    use textbook_class
    use physics_functions
    use model_class

    implicit none

    type ,extends(modelSurrogate) ,public :: dummyModel 

    end type dummyModel

    type ,extends(derivation) ,public :: testDerivation 

    contains 

    procedure ,public :: calculate => testCalculate

    end type testDerivation

    type ,extends(derivation) ,public :: testDerivation2 

    contains 

    procedure ,public :: calculate => testCalculate2

    end type testDerivation2

contains

    @test( npes=[8])
    subroutine test_diagonal_stencil(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(indexing) :: testIndexing
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(1) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(CoordProfiles) :: cProfs
        type(StencilTemplate) :: testTemplate ,testTemplate2
        type(VarData) :: vData
        type(EnvironmentWrapper) :: envObj
        type(Geometry) :: testGeometry
        type(VSpace) :: testVSpace

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr ,hArr

        integer(ik) ,dimension(2) :: locHs

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i,i=1,3)],kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.)
        call testList%addVar("u")

        call testListDerived%init()

        call testListDerived%addVar("p")

        call testIndexing%init(testPart,testGrid,testList)

        call testGeometry%init([(real(1,kind=rk),i=1,12)],[(real(1,kind=rk),i=1,12)],[(real(1,kind=rk),i=1,12)])

        call cRules(1)%init()

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())
        locHs = [testPart%getMinHAtInd(testController%getWorldRank()+1),testPart%getMaxHAtInd(testController%getWorldRank()+1)]

        envObj%gridObj = testGrid
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call envObj%makeDefined()
        hArr=real([2,3,3,4],kind=rk)

        call initKinDiagonalStencilTemplateDirect(testTemplate,envObj,"f","f",[(i,i=1,12)],[1,2,3,4],[1,2,3])

        vData%rowVars = [stringArray("f"),stringArray("p")]
        vData%rowVarPowers = [2.0d0,-1.0d0]
        cProfs%hProfile = hArr 
        cProfs%vProfile = real([1,2,3],kind=rk)

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,testTemplate,&
                            vData=vData,coordProfile=cProfs)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = real([1,1,1],kind=rk)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,xArr,vArr)
        end do

        testVarCont1%variables(2)%entry = real([1,2,3,4,5],kind=rk)
        testVarCont1%variables(3)%entry = real([3,2,3,1,2],kind=rk)

        call testTerm%calculateValues(testVarCont1)
        xArr = xArr ** 3 /testVarCont1%variables(3)%entry
        xArr(1) = 0
        xArr(5) = 0
        vArr = real([1,2,3],kind=rk)

        testVec = testTerm%evaluate(testVarCont1)
        allocate(checkVec,source=testVec)
        checkVec = 0 
        do i = 1,2 
            call setDistHarmonic(checkVec,locHs(i),hArr(locHs(i))*xArr,vArr)
        end do

        @assertEqual(testVec,checkVec,tolerance=1.d-14)
        
        call initKinDiagonalStencilTemplateDirect(testTemplate2,envObj,"f","u",[(i,i=1,12)],[1,2,3,4],[1,2,3])

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","u",testVarCont1,testTemplate2,&
                            vData=vData,coordProfile=cProfs)

        call testTerm2%calculateValues(testVarCont1)

        xArr = real([1,2,3,4,5],kind=rk) ** 2 * testVarCont1%variables(2)%entry/testVarCont1%variables(3)%entry
        xArr(1) = 0
        xArr(5) = 0
        vArr = real([1,2,3],kind=rk)

        testVec = testTerm2%evaluate(testVarCont1)
        checkVec = 0 
        do i = 1,2 
            call setDistHarmonic(checkVec,locHs(i),hArr(locHs(i))*xArr,vArr)
        end do

        @assertEqual(testVec,checkVec,tolerance=1.d-14)
    end subroutine test_diagonal_stencil

    @test( npes=[8])
    subroutine test_spatial_diff_stencil(this)
    
        type(Partition) :: testPart
        class(MpiTestMethod), intent(inout) :: this
        type(Grid) :: testGrid
        type(VariableList) :: testList,testListDerived
        type(Indexing) :: testIndexing
        type(VariableContainer) :: testVarCont1
        type(CalculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm 
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(Geometry) :: testGeometry
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj 
        type(CoordProfiles) :: cProfs
        type(VSpace) :: testVSpace 
        type(EnvironmentWrapper) :: envObj
        integer(ik) :: i ,minH 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr
        real(rk) :: minXVal, maxXVal

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i,i=1,3)],kind=rk),3,0)

        call testList%init()
        call testList%addVar("f",.true.)

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call initSpatialDiffStencilTemplateDirect(templateObj,envObj,"f","f",1,2)
        minH = testPart%getMinHAtInd(testController%getWorldRank()+1)
        
        cProfs%vProfile = - testGrid%getVGrid()
        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj,&
                           coordProfile=cProfs)

        call testTerm%calculateValues(testVarCont1)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = real([1,1,1],kind=rk)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,xArr,vArr)
        end do

        testVec = testTerm%evaluate(testVarCont1)
        minXVal = real(1,kind=rk)
        maxXVal = minXVal
        vArr = real([1,2,3],kind=rk)
        if (testPart%getMinXAtInd(testController%getWorldRank()+1) == 1) minXVal = real(2.5d00,kind=rk)
        if (testPart%getMaxXAtInd(testController%getWorldRank()+1) == 12) maxXVal = -real(3.5d00,kind=rk)
        allocate(checkVec,source=testVec)
        checkVec = 0 

        xArr = real([0.0d0,minXVal,1.0d0,maxXVal,0.0d0],kind=rk)
        if (minH == 1) then 
            call setDistHarmonic(checkVec,1,-xArr,vArr)
        end if

        @assertEqual(testVec,checkVec,tolerance=1.d-14)

    end subroutine test_spatial_diff_stencil

    @test( npes=[8])
    subroutine test_spatial_diff_stencil_stag(this)
    
        type(Partition) :: testPart
        class(MpiTestMethod), intent(inout) :: this
        type(Grid) :: testGrid
        type(VariableList) :: testList,testListDerived
        type(Indexing) :: testIndexing
        type(VariableContainer) :: testVarCont1
        type(CalculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm 
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(Geometry) :: testGeometry
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj 
        type(CoordProfiles) :: cProfs
        type(VSpace) :: testVSpace 
        type(EnvironmentWrapper) :: envObj
        integer(ik) :: i ,minH 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr
        real(rk) :: minXVal, maxXVal

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i,i=1,3)],kind=rk),3,0)

        call testList%init()
        call testList%addVar("f",.true.,isOnDualGrid=.true.)

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call initSpatialDiffStencilTemplateDirect(templateObj,envObj,"f","f",1,2)
        minH = testPart%getMinHAtInd(testController%getWorldRank()+1)
        
        cProfs%vProfile = - testGrid%getVGrid()
        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj,&
                           coordProfile=cProfs)

        call testTerm%calculateValues(testVarCont1)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = real([1,1,1],kind=rk)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,xArr,vArr)
        end do

        testVec = testTerm%evaluate(testVarCont1)
        minXVal = real(1,kind=rk)
        maxXVal = minXVal
        vArr = real([1,2,3],kind=rk)
        if (testPart%getMinXAtInd(testController%getWorldRank()+1) == 1) minXVal = real(2.0d00,kind=rk)
        if (testPart%getMaxXAtInd(testController%getWorldRank()+1) == 12) maxXVal = -real(3.0d00,kind=rk)
        allocate(checkVec,source=testVec)
        checkVec = 0 

        xArr = real([0.0d0,minXVal,1.0d0,maxXVal,0.0d0],kind=rk)
        if (minH == 1) then 
            call setDistHarmonic(checkVec,1,-xArr,vArr)
        end if

        @assertEqual(testVec,checkVec,tolerance=1.d-14)

    end subroutine test_spatial_diff_stencil_stag

    @test( npes=[8])
    subroutine test_moment_stencil(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(indexing) :: testIndexing
        type(VSpace) :: testVSpace
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm 
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj 
        type(Geometry) :: testGeometry
        type(EnvironmentWrapper) :: envObj
        type(VarData) :: vData
        integer(ik) :: i 

        call testPart%initSimplePartition(4,2,12,2)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(0.1d0*i,i=1,10)]-0.05d0,kind=rk),1,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("n")
        call testList%addVar("f",.true.)

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call initMomentStencilTemplateDirect(templateObj,envObj,"n","f",1,2)
        vData%rowVars=[stringArray("n")]
        vData%rowVarPowers = [2.0d0]

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
                          "n","f",testVarCont1,templateObj,vData=vData)

        testVarCont1%variables(1)%entry = real([2,4,6,4,5],kind=rk)

        do i = 1,2
            call setDistHarmonic(testVarCont1%variables(2)%entry,i,real([1,2,3,4,5],kind=rk),[(real(1,kind=rk),i=1,10)])
        end do

        call testTerm%calculateValues(testVarCont1)

        testVec = testTerm%evaluate(testVarCont1)
        allocate(checkVec(5))
        checkVec = 0 
        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) &
        checkVec = testVSpace%calculateMoment(testVarCont1%variables(2)%entry,1,2)*testVarCont1%variables(1)%entry**2

        checkVec(1) = 0
        checkVec(5) = 0
        @assertEqual(testVec,checkVec,tolerance=1.d-13)
        
    end subroutine test_moment_stencil

    @test( npes=[8])
    subroutine test_moment_stencil_stag(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(indexing) :: testIndexing
        type(VSpace) :: testVSpace
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm 
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj 
        type(Geometry) :: testGeometry
        type(EnvironmentWrapper) :: envObj

        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr ,interpF
        integer(ik) :: i 

        call testPart%initSimplePartition(4,2,12,2)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(0.1d0*i,i=1,10)]-0.05d0,kind=rk),1,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("n")
        call testList%addVar("f",.true.,isOnDualGrid=.true.)

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call initMomentStencilTemplateDirect(templateObj,envObj,"n","f",2,2)

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
                          "n","f",testVarCont1,templateObj)

        testVarCont1%variables(1)%entry = real([2,4,6,4,5],kind=rk)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = [(real(1,kind=rk),i=1,10)]
        do i = 1,2
            call setDistHarmonic(testVarCont1%variables(2)%entry,i,xArr,vArr)
        end do

        allocate(interpF,source = testVarCont1%variables(2)%entry)
        interpF = 0

        call setDistHarmonic(interpF,2,real([0.0d0,1.5d0,2.5d0,3.5d0,0d0],kind=rk),vArr)

        call testTerm%calculateValues(testVarCont1)

        testVec = testTerm%evaluate(testVarCont1)
        allocate(checkVec(5))
        checkVec = 0 
        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) &
        checkVec = testVSpace%calculateMoment(interpF,2,2)

        @assertEqual(testVec,checkVec,tolerance=1.d-14)
        
    end subroutine test_moment_stencil_stag


    @test( npes=[8])
    subroutine test_ij_stencil_template(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(indexing) :: testIndexing
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(VSpace) :: testVSpace
        type(StencilTemplate) :: templateObj ,templateObj2
        type(CoordProfiles) :: cProfs
        type(EnvironmentWrapper) :: envObj 
        type(Geometry) :: testGeometry

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr ,vWidths ,vGrid ,vdvArr

        type(SparseRowData) :: jMat ,iMat

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(0.1d0*i,i=1,10)]-0.05d0,kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.,isOnDualGrid=.true.)
        call testList%addVar("u")

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())
        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        allocate(vArr(10))
        vArr = real(1,kind=rk)

        vWidths = testVSpace%getVCellWidths()
        vGrid = testGrid%getVGrid()

        vdvArr = 4*pi*vGrid*vWidths

        jMat = testVSpace%getShkarofskyJMat(-1)
        iMat = testVSpace%getShkarofskyIMat(-1)

        call initIJStencilTemplateDirect(templateObj,envObj,"f","f",1,1,-1,.false.)

        cProfs%vProfile = vGrid**(-1)
        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
                          "f","f",testVarCont1,templateObj,coordProfile = cProfs)

        xArr = real([1,2,3,4,5],kind=rk)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,xArr,vArr)
        end do

        testVarCont1%variables(2)%entry = real([1,2,3,4,5],kind=rk)

        call testTerm%calculateValues(testVarCont1)
        xArr(1) = 0
        xArr(5) = 0

        do i = 1,10
            vArr(i) = sum(vdvArr(1:i)) - 2*pi*vGrid(i)*vWidths(i)
        end do


        testVec = testTerm%evaluate(testVarCont1)
        allocate(checkVec,source=testVec)
        checkVec = 0 
        call setDistHarmonic(checkVec,1,xArr,vArr)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1)==1)&
        @assertEqual(testVec,checkVec,tolerance=1.d-12)

        call initIJStencilTemplateDirect(templateObj2,envObj,"f","f",1,2,-1,.true.)


        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
                          "f","f",testVarCont1,templateObj2,coordProfile = cProfs)

        call testTerm2%calculateValues(testVarCont1)

        do i = 1,10
            vArr(i) = sum(vdvArr(i:10)) - 2*pi*vGrid(i)*vWidths(i)
        end do
        if (testPart%getMinHAtInd(testController%getWorldRank()+1)==1) then
            testVec = testTerm2%evaluate(testVarCont1)
            checkVec = 0 
            call setDistHarmonic(checkVec,1,real([0.0d0,1.5d0,2.5d0,3.5d0,0d0],kind=rk),vArr)
            @assertEqual(testVec,checkVec,tolerance=1.d-12)
        end if

    end subroutine test_ij_stencil_template

    @test( npes=[8])
    subroutine test_ddv_stencil_template(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(VSpace) :: testVSpace
        type(indexing) :: testIndexing
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: testTemplate ,testTemplate2
        type(VarData) :: vData 
        type(EnvironmentWrapper) :: envObj 
        type(Geometry) :: testGeometry

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr ,dvArr ,vArrCellEdge,vInterp

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(0.05d00 + (i-1)**2*0.1d0,i=1,10)],kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.,isOnDualGrid=.true.)
        call testList%addVar("u")

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call initDDVStencilTemplateDirect(testTemplate,envObj,"f","f",1,3)
        vData%rowVars = [stringArray("f"),stringArray("u")]
        vData%rowVarPowers = [1.0d0,-1.0d0]
        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
        "f","f",testVarCont1,testTemplate,vData=vData)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = exp(-testGrid%getVGrid()**2)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,i*xArr,vArr)
        end do

        testVarCont1%variables(2)%entry = real([1,4,1,2,5],kind=rk)

        call testTerm%calculateValues(testVarCont1)

        allocate(dvArr(10))
        allocate(vArrCellEdge(0:10))

        vInterp = testVSpace%getVLinInterp()
        vArrCellEdge = 0

        do i = 1,9
            vArrCellEdge(i) = vArr(i)*(real(1,kind=rk)-vInterp(i)) + vArr(i+1)*vInterp(i)
        end do

        dvArr = (vArrCellEdge(1:10)-vArrCellEdge(0:9))*vArr/testVSpace%getVCellWidths()

        testVec = testTerm%evaluate(testVarCont1)
        allocate(checkVec,source=testVec)
        xArr = 3*xArr**2/testVarCont1%variables(2)%entry
        
        xArr(1) = 0 
        xArr(5) = 0
        checkVec = 0

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then 
            call setDistHarmonic(checkVec,1,xArr,dvArr)
        end if

        @assertEqual(testVec,checkVec,tolerance=1.d-12)

        dvArr = 0.5d00

        call initDDVStencilTemplateDirect(testTemplate2,envObj,"f","f",1,2,fixedC=vInterp,fixedInterp=dvArr,&
                                          cfAtZero=[0.5d00*vInterp(1),0.5d00*vInterp(1)])

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
        "f","f",testVarCont1,testTemplate2)

        call testTerm2%calculateValues(testVarCont1)

        vArrCellEdge = 0

        do i = 1,9
            vArrCellEdge(i) = (vArr(i) + vArr(i+1))/2
        end do

        dvArr(2:10) = (vArrCellEdge(2:10)*vInterp(2:10)-vArrCellEdge(1:9)*vInterp(1:9))

        dvArr(1) = 0

        dvArr = dvArr/testVSpace%getVCellWidths()

        testVec = testTerm2%evaluate(testVarCont1)

        xArr = 2*real([0.0d0,1.5d0,2.5d0,3.5d0,0.0d0],kind=rk)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then 
            call setDistHarmonic(checkVec,1,xArr,dvArr)
        end if

        @assertEqual(testVec,checkVec,tolerance=1.d-12)

    end subroutine test_ddv_stencil_template

    @test( npes=[8])
    subroutine test_vel_diff_stencil_template(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(VSpace) :: testVSpace
        type(indexing) :: testIndexing
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: testTemplate ,testTemplate2
        type(VarData) :: vData 
        type(EnvironmentWrapper) :: envObj 
        type(Geometry) :: testGeometry

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr ,dvArr ,vArrCellEdge,vInterp,vGridCopy

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(0.05d00 + (i-1)**2*0.1d0,i=1,10)],kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.,isOnDualGrid=.true.)
        call testList%addVar("u")

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call initVelDiffusionStencilTemplateDirect(testTemplate,envObj,"f","f",1,3)
        vData%rowVars = [stringArray("f"),stringArray("u")]
        vData%rowVarPowers = [1.0d0,-1.0d0]

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
        "f","f",testVarCont1,testTemplate,vData=vData)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = exp(-testGrid%getVGrid()**2)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,i*xArr,vArr)
        end do

        testVarCont1%variables(2)%entry = real([1,4,1,2,5],kind=rk)

        call testTerm%calculateValues(testVarCont1)

        allocate(dvArr(10))
        allocate(vArrCellEdge(0:10))

        vInterp = testVSpace%getVLinInterp()
        vArrCellEdge = 0
        vGridCopy = testGrid%getVGrid()
        do i = 1,9
            vArrCellEdge(i) = (vArr(i+1)-vArr(i))/(vGridCopy(i+1)-vGridCopy(i))
        end do

        dvArr = (vArrCellEdge(1:10)-vArrCellEdge(0:9))*vArr/testVSpace%getVCellWidths()

        testVec = testTerm%evaluate(testVarCont1)
        allocate(checkVec,source=testVec)
        xArr = 3*xArr**2/testVarCont1%variables(2)%entry
        
        xArr(1) = 0 
        xArr(5) = 0
        checkVec = 0

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then 
            call setDistHarmonic(checkVec,1,xArr,dvArr)
        end if

        @assertEqual(testVec,checkVec,tolerance=1.d-12)

        dvArr = 0.5d00

        call initVelDiffusionStencilTemplateDirect(testTemplate2,envObj,"f","f",1,2,fixedA=vInterp,&
                                                   adfAtZero=[-vInterp(1),vInterp(1)]/0.1d00)

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),&
        "f","f",testVarCont1,testTemplate2)

        call testTerm2%calculateValues(testVarCont1)

        vArrCellEdge = 0

        do i = 1,9
            vArrCellEdge(i) = vInterp(i)*(vArr(i+1)-vArr(i))/(vGridCopy(i+1)-vGridCopy(i))
        end do

        dvArr(2:10) = (vArrCellEdge(2:10)-vArrCellEdge(1:9))

        dvArr(1) = 0

        dvArr = dvArr/testVSpace%getVCellWidths()

        xArr = 2*real([0.0d0,1.5d0,2.5d0,3.5d0,0.0d0],kind=rk)

        testVec = testTerm2%evaluate(testVarCont1)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then 
            call setDistHarmonic(checkVec,1,xArr,dvArr)
        end if

        @assertEqual(testVec,checkVec,tolerance=1.d-12)

    end subroutine test_vel_diff_stencil_template

    @test( npes=[8])
    subroutine test_boltz_stencil_template(this)
    
        type(Partition) :: testPart
        class(MpiTestMethod), intent(inout) :: this
        type(Grid) :: testGrid
        type(VariableList) :: testList,testListDerived
        type(Indexing) :: testIndexing
        type(VariableContainer) :: testVarCont1
        type(CalculationRule) ,dimension(1) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2 ,testTerm3 ,testTerm4
        real(rk) ,allocatable ,dimension(:) :: testVec,rateVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj ,templateObj2 ,templateObj3 ,templateObj4
        type(VSpace) ,target:: testVSpace
        type(FixedECSTransition) :: testFixedECSTransition
        type(DBTransition) :: testDBTransition
        type(InelasticGridData) :: testInelGrid
        type(ModelboundCRMData) :: testCRMData
        type(dummyModel) :: dummyM
        type(EnvironmentWrapper) :: envObj
        type(Geometry) :: testGeometry

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr 
        real(rk) ,allocatable ,dimension(:,:) :: cSection

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i*1.0d0 - 0.5d0,i=1,10)],kind=rk),1,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.)

        call testListDerived%init()
        call testListDerived%addVar("T")

        call cRules(1)%init()
        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        xArr = real([1,2,3,4,5],kind=rk)*pi**(-1.5d0)
        call setDistHarmonic(testVarCont1%variables(1)%entry,1,xArr,exp(-testGrid%getVGrid()**2))

        testVarCont1%variables(2)%entry = xArr

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        allocate(cSection(10,1))
        cSection = real(1.0d0)

        call testFixedECSTransition%init(3,[0,2],[0,3],3.5d0,cSection,1,testVSpace,1)
        call testDBTransition%init(3,[0,3],[0,2],-3.5d0,1,testVSpace,1,1,2,2,0,real(1,kind=rk))

        call testCRMData%init(2)
        call testCRMData%addTransition(testFixedECSTransition)
        call testCRMData%addTransition(testDBTransition)

        call testInelGrid%init(testVSpace,fixedEnergies=[3.5d0,-3.5d0])

        call testCRMData%setInelData(testInelGrid)
        call testCRMData%update(dummyM,testVarCont1)

        call initFixedBoltzmannStencilDirect(templateObj,envObj,"f","f",testCRMData,1,1,1,.false.,.false.)
        
        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj&
                          ,mbData=testCRMData)

        call dummyM%makeDefined()

        call testTerm%update(testVarCont1,modelData=testCRMData)
        call testTerm%calculateValues(testVarCont1)

        testVec = testTerm%evaluate(testVarCont1)
        rateVec = -testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(1),tolerance=1.0d-14)
        end if  

        call initFixedBoltzmannStencilDirect(templateObj2,envObj,"f","f",testCRMData,1,1,1,.true.,.false.)

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj2,&
                           mbData=testCRMData)

        call testTerm2%update(testVarCont1,modelData=testCRMData)
        call testTerm2%calculateValues(testVarCont1)

        testVec = testTerm2%evaluate(testVarCont1)
        rateVec = testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(1),tolerance=1.0d-14)
        end if
        
        call initFixedBoltzmannStencilDirect(templateObj3,envObj,"f","f",testCRMData,1,2,2,.false.,.true.)

        call testTerm3%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj3,&
        mbData=testCRMData)

        call testTerm3%update(testVarCont1,modelData=testCRMData)
        call testTerm3%calculateValues(testVarCont1)

        testVec = testTerm3%evaluate(testVarCont1)
        rateVec = - testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(2),tolerance=1.0d-14)
        end if

        call initFixedBoltzmannStencilDirect(templateObj4,envObj,"f","f",testCRMData,1,2,2,.true.,.true.)

        call testTerm4%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj4,&
        mbData=testCRMData)

        call testTerm4%update(testVarCont1,modelData=testCRMData)
        call testTerm4%calculateValues(testVarCont1)

        testVec = testTerm4%evaluate(testVarCont1)
        rateVec = testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(2),tolerance=1.0d-12)
        end if

    end subroutine test_boltz_stencil_template

    @test( npes=[8])
    subroutine test_lbc(this)
    
        type(Partition) :: testPart
        class(MpiTestMethod), intent(inout) :: this
        type(Grid) :: testGrid
        type(VSpace) :: testVSpace
        type(VariableList) :: testList,testListDerived
        type(Indexing) :: testIndexing
        type(VariableContainer) :: testVarCont1
        type(CalculationRule) ,dimension(4) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2,testTerm3
        real(rk) ,allocatable ,dimension(:) :: testVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj ,templateObj2 ,templateObj3
        type(FScalingDerivation) :: derivObj ,derivObj2
        type(ModelboundLBCData) :: mbData,mbData2
        type(dummyModel) :: dummyM
        type(Geometry) :: testGeometry
        type(Textbook) :: textbookObj 
        type(EnvironmentWrapper) :: envObj

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr , flux

        logical :: isActive

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(0.05d0+0.1d0*1.05**(i-1),i=1,80)],kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.,isOnDualGrid=.true.)

        call testListDerived%init()
        call testListDerived%addVar("nb",isScalar=.true.)
        call testListDerived%addVar("n")
        call testListDerived%addVar("ji",isScalar=.true.)
        call testListDerived%addVar("n_dual")

        do i = 1,4
            call cRules(i)%init()
        end do 
        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        xArr = real([1,2,3,4,5],kind=rk)*pi**(-1.5d0)
        call setDistHarmonic(testVarCont1%variables(1)%entry,1,xArr,exp(-testGrid%getVGrid()**2))

        testVarCont1%variables(2)%entry = real(3,kind=rk)
        testVarCont1%variables(3)%entry = real([1,2,3,4,5],kind=rk)
        testVarCont1%variables(4)%entry = -3*vSonic(1.0d0,1.0d0,protonMass*2,1.0d0,1.0d0)/elVthermal(1.0d0)
        testVarCont1%variables(5)%entry = real([1,1,2,3,4],kind=rk)

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        isActive = testPart%getMinHAtInd(testController%getWorldRank()+1) == 1 &
        .and. testPart%getMinXAtInd(testController%getWorldRank()+1) == 1

        call derivObj%init(testPart,testController%getWorldRank(),testGrid%getNumV(),&
                            leftBoundary=.true.,extrapolateToBoundary=.true.)

        call derivObj2%init(testPart,testController%getWorldRank(),testGrid%getNumV(),&
                            staggeredVars=.true.,extrapolateToBoundary=.true.)

        call textbookObj%init()
        call textbookObj%addMatDerivation(derivObj,"deriv1")
        call textbookObj%addMatDerivation(derivObj2,"deriv2")

        call mbData%init(testVSpace,derivObj,[1,3,2],4,isActive,isLeftBoundary=.true.)
        call dummyM%makeDefined()
        call mbData%update(dummyM,testVarCont1)

        envObj%textbookObj = textbookObj
        
        call initScalingLBCStencilDirect(templateObj,envObj,"f","f",1,2,[1,2,3,4],"deriv1",&
                                        [StringArray("f"),StringArray("n"),StringArray("nb")],leftBoundary=.true.)

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj,&
                            mbData=mbData)

        call testTerm%update(testVarCont1,modelData=mbData)
        call testTerm%calculateValues(testVarCont1)

        testVec = testTerm%evaluate(testVarCont1)
        flux = testVSpace%calculateMoment(testVec,1,0)/real(3,kind=rk)
        if (isActive) then 
            @assertEqual(flux(2),testVarCont1%variables(4)%entry(1),tolerance=1.d-12)
            deallocate(flux)

            call mbData%copyData("gamma",flux) !Todo: automate this check as well?
            print*,flux
        end if

        testVarCont1%variables(4)%entry = 3*vSonic(1.0d0,1.0d0,protonMass*2,1.0d0,1.0d0)/elVthermal(1.0d0)

        isActive = testPart%getMinHAtInd(testController%getWorldRank()+1) == 1 &
        .and. testPart%getMaxXAtInd(testController%getWorldRank()+1) == 12

        call mbData2%init(testVSpace,derivObj2,[1,3,5,2],4,isActive)
        call mbData2%update(dummyM,testVarCont1)

        call initScalingLBCStencilDirect(templateObj2,envObj,"f","f",1,2,[1,3],"deriv2",&
                                        [StringArray("f"),StringArray("n"),StringArray("n_dual"),StringArray("nb")])

        
        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj2,&
                        mbData = mbData2)

        call initScalingLBCStencilDirect(templateObj3,envObj,"f","f",1,2,[2,4],"deriv2",&
                        [StringArray("f"),StringArray("n"),StringArray("n_dual"),StringArray("nb")])
        
        call testTerm3%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj3,&
                            mbData = mbData2)

        call testTerm2%update(testVarCont1,modelData=mbData2)
        call testTerm2%calculateValues(testVarCont1)
        call testTerm3%update(testVarCont1,modelData=mbData2)
        call testTerm3%calculateValues(testVarCont1)

        testVec = testTerm2%evaluate(testVarCont1)
        flux = testVSpace%calculateMoment(testVec,1,0)/real(3,kind=rk) 
        testVec = testTerm3%evaluate(testVarCont1)
        flux = flux + testVSpace%calculateMoment(testVec,1,0)/real(3,kind=rk) 

        if (isActive) then 
            @assertEqual(flux(4),testVarCont1%variables(4)%entry(1),tolerance=1.d-12)
            deallocate(flux)

            call mbData2%copyData("gamma",flux) !Todo: automate this check as well?
            print*,flux
        end if
    end subroutine test_lbc

    @test( npes=[8])
    subroutine test_term_moment_stencil(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(indexing) :: testIndexing
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(0) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2 ,testTerm3, testTerm4
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: testTemplate ,testTemplate2, testTemplate3 ,testTemplate4
        type(EnvironmentWrapper) :: envObj
        type(Geometry) :: testGeometry
        type(VSpace) :: testVSpace
        class(MatrixTerm) ,allocatable :: matBuffer
        type(Model) :: testModel 

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr ,xArrInterp

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i*0.1d0,i=1,10)]-0.05d0,kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.,isOnDualGrid=.true.)
        call testList%addVar("u",isOnDualGrid=.true.)
        call testList%addVar("n")

        call testListDerived%init()

        call testIndexing%init(testPart,testGrid,testList)

        call testGeometry%init([(real(1,kind=rk),i=1,12)],[(real(1,kind=rk),i=1,12)],[(real(1,kind=rk),i=1,12)])

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        envObj%gridObj = testGrid
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace
        envObj%partitionObj = testPart

        call envObj%makeDefined()

        call initKinDiagonalStencilTemplateDirect(testTemplate,envObj,"f","f",[(i,i=1,11)],[2],[(i,i=1,10)])

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,testTemplate)

        xArr = real([1,2,3,4,5],kind=rk)
        allocate(vArr(10))
        vArr = real(1,kind=rk)
        call setDistHarmonic(testVarCont1%variables(1)%entry,2,xArr,vArr)

        call initTermMomentStencilDirect(testTemplate2,envObj,"u","f",1,2,"firstTerm")

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"u","f",testVarCont1,testTemplate2)

        call initKinDiagonalStencilTemplateDirect(testTemplate3,envObj,"f","n",[(i,i=1,11)],[2],[(i,i=1,10)])

        call testTerm3%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","n",testVarCont1,testTemplate3)

        testVarCont1%variables(3)%entry = xArr

        call initTermMomentStencilDirect(testTemplate4,envObj,"u","n",1,2,"secondTerm")

        call testTerm4%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"u","n",testVarCont1,testTemplate4)

        call testModel%init(2,0,1,1)
        allocate(matBuffer,source=testTerm)
        call testModel%addImplicitTerm(matBuffer,[1],[1],"firstTerm")
        allocate(matBuffer,source=testTerm3)
        call testModel%addImplicitTerm(matBuffer,[1],[1],"secondTerm")
        call testModel%assemble()
        call testModel%calculateMatGroupValues(1,testVarCont1)
        call testTerm2%update(testVarCont1,hostModel=testModel)
        call testTerm4%update(testVarCont1,hostModel=testModel)
        call testTerm2%calculateValues(testVarCont1)
        call testTerm4%calculateValues(testVarCont1)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1)==1) then
            testVec = testTerm2%evaluate(testVarCont1)
            checkVec = testVSpace%calculateMoment(testVarCont1%variables(1)%entry,2,1) 
            checkVec(1) = 0
            if (testPart%getMaxXAtInd(testController%getWorldRank()+1) == 12) checkVec(4) = 0
            checkVec(5) = 0
            @assertEqual(testVec,checkVec,tolerance=1.d-14)

            xArrInterp = real([0.0,2.5,3.5,4.5,0.0],kind=rk)
            testVec = testTerm4%evaluate(testVarCont1)
            checkVec = testVSpace%calculateMoment(testVarCont1%variables(1)%entry,2,1) /xArr * xArrInterp
            if (testPart%getMaxXAtInd(testController%getWorldRank()+1) == 12) checkVec(4) = 0
            @assertEqual(testVec,checkVec,tolerance=1.d-14)
        end if

    end subroutine test_term_moment_stencil

    @test( npes=[8])
    subroutine test_copy_term(this)
    
        type(partition) :: testPart
        class (MpiTestMethod), intent(inout) :: this
        type(grid) :: testGrid
        type(variableList) :: testList,testListDerived
        type(indexing) :: testIndexing
        type(variableContainer) :: testVarCont1
        type(calculationRule) ,dimension(1) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2
        real(rk) ,allocatable ,dimension(:) :: testVec,checkVec
        type(MPIController) :: testController 
        type(CoordProfiles) :: cProfs
        type(StencilTemplate) :: testTemplate ,testTemplate2
        type(VarData) :: vData
        type(EnvironmentWrapper) :: envObj
        type(Geometry) :: testGeometry
        type(VSpace) :: testVSpace
        type(Model) :: testModel
        class(MatrixTerm) ,allocatable :: matBuffer
        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr ,vArr

        integer(ik) ,dimension(2) :: locHs

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i,i=1,3)],kind=rk),3,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.)
        call testList%addVar("u")

        call testListDerived%init()

        call testListDerived%addVar("p")

        call testIndexing%init(testPart,testGrid,testList)

        call testGeometry%init([(real(1,kind=rk),i=1,12)],[(real(1,kind=rk),i=1,12)],[(real(1,kind=rk),i=1,12)])

        call cRules(1)%init()

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())
        locHs = [testPart%getMinHAtInd(testController%getWorldRank()+1),testPart%getMaxHAtInd(testController%getWorldRank()+1)]

        envObj%gridObj = testGrid
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call envObj%makeDefined()

        call initKinDiagonalStencilTemplateDirect(testTemplate,envObj,"f","f",[(i,i=1,12)],[1],[1,2,3])

        vData%rowVars = [stringArray("f"),stringArray("p")]
        vData%rowVarPowers = [2.0d0,-1.0d0]
        cProfs%vProfile = real([1,2,3],kind=rk)

        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,testTemplate,&
                            vData=vData,coordProfile=cProfs)

        xArr = real([1,2,3,4,5],kind=rk)
        vArr = real([1,1,1],kind=rk)
        do i = 1,4
            call setDistHarmonic(testVarCont1%variables(1)%entry,i,xArr,vArr)
        end do

        testVarCont1%variables(2)%entry = real([1,2,3,4,5],kind=rk)
        testVarCont1%variables(3)%entry = real([3,2,3,1,2],kind=rk)

        call testModel%init(1,0,1,1)
        allocate(matBuffer,source=testTerm)
        call testModel%addImplicitTerm(matBuffer,[1],[1],"testTerm1")
        call testModel%assemble()
        call testModel%calculateMatGroupValues(1,testVarCont1)
        
        call initKinDiagonalStencilTemplateDirect(testTemplate2,envObj,"f","u",[(i,i=1,12)],[1],[1,2,3])

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","u",testVarCont1,testTemplate2,&
                            copyTermName="testTerm1")
        
        call testTerm2%update(testVarCont1,hostModel=testModel)
        call testTerm2%calculateValues(testVarCont1)

        xArr = real([1,2,3,4,5],kind=rk) ** 2 * testVarCont1%variables(2)%entry/testVarCont1%variables(3)%entry
        xArr(1) = 0
        xArr(5) = 0
        vArr = real([1,2,3],kind=rk)
        
        testVec = testTerm2%evaluate(testVarCont1)
        allocate(checkVec,source=testVec)
        checkVec = 0 
        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            call setDistHarmonic(checkVec,1,xArr,vArr)

            @assertEqual(testVec,checkVec,tolerance=1.d-14)
        end if
    end subroutine test_copy_term

    @test( npes=[8])
    subroutine test_var_boltz_stencil_template(this)
    
        type(Partition) :: testPart
        class(MpiTestMethod), intent(inout) :: this
        type(Grid) :: testGrid
        type(VariableList) :: testList,testListDerived
        type(Indexing) :: testIndexing
        type(VariableContainer) :: testVarCont1
        type(CalculationRule) ,dimension(2) :: cRules
        type(GeneralMatrixTerm) :: testTerm ,testTerm2 ,testTerm3 ,testTerm4
        real(rk) ,allocatable ,dimension(:) :: testVec,rateVec
        type(MPIController) :: testController 
        type(StencilTemplate) :: templateObj ,templateObj2 ,templateObj3 ,templateObj4
        type(VSpace) ,target:: testVSpace
        type(VariableECSTransition) :: testVariableECSTransition, testVariableECSTransition2
        type(InelasticGridData) :: testInelGrid
        type(ModelboundCRMData) :: testCRMData
        type(dummyModel) :: dummyM
        type(EnvironmentWrapper) :: envObj
        type(Geometry) :: testGeometry
        type(testDerivation) :: testDeriv
        type(testDerivation2) :: testDeriv2
        type(DerivationContainer) ,dimension(1) :: derivCont

        integer(ik) :: i 
        real(rk) ,allocatable ,dimension(:) :: xArr 

        call testPart%initSimplePartition(4,2,12,4)
        call testController%init(4,2)

        call testGrid%init(real([(i,i=1,12)],kind=rk)-0.5d0,real([(i*1.0d0 - 0.5d0,i=1,10)],kind=rk),1,0)
        call testVSpace%init(testGrid)

        call testList%init()
        call testList%addVar("f",.true.)

        call testListDerived%init()
        call testListDerived%addVar("En")
        call testListDerived%addVar("En2")

        call cRules(1)%init()
        call cRules(2)%init()
        call testIndexing%init(testPart,testGrid,testList)

        call testVarCont1%init(testList,testListDerived,cRules,testIndexing,testPart,1,testController%getWorldRank())

        xArr = real([1,2,3,4,5],kind=rk)*pi**(-1.5d0)
        call setDistHarmonic(testVarCont1%variables(1)%entry,1,xArr,exp(-testGrid%getVGrid()**2))

        testVarCont1%variables(2)%entry = real([1,2,3,4,5],kind=rk)
        testVarCont1%variables(3)%entry = - real([1,2,3,4,5],kind=rk)

        call testGeometry%init(real([(1.0d0,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk),real([(1,i=1,12)],kind=rk))

        envObj%gridObj = testGrid
        envObj%partitionObj = testPart
        envObj%mpiCont = testController
        envObj%indexingObj = testIndexing
        envObj%externalVars = testVarCont1
        envObj%geometryObj = testGeometry
        envObj%vSpaceObj = testVSpace

        call testDeriv%makeDefined()
        call testDeriv2%makeDefined()
        allocate(derivCont(1)%entry,source=testDeriv2)

        call testVariableECSTransition%init(3,[0,2],[0,3],testDeriv,[2],derivCont,&
                                            [IntArray([2])],[1],1,testVSpace)
        call testVariableECSTransition2%init(3,[0,2],[0,3],testDeriv,[3],derivCont,&
                                            [IntArray([2])],[1],1,testVSpace)

        call testCRMData%init(2)
        call testCRMData%addTransition(testVariableECSTransition)
        call testCRMData%addTransition(testVariableECSTransition2)

        call testInelGrid%init(testVSpace,fixedEnergies=[3.5d0,-3.5d0],&
        interpolationGrid = [(i*1.0d0 - 0.5d0,i=-9,10)])


        call testCRMData%setInelData(testInelGrid)
        call testCRMData%update(dummyM,testVarCont1)

        call initVariableBoltzmannStencilDirect(templateObj,envObj,"f","f",testCRMData,1,1,.false.,.false.)
        
        call testTerm%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj&
                          ,mbData=testCRMData)

        call dummyM%makeDefined()

        call testTerm%update(testVarCont1,modelData=testCRMData)
        call testTerm%calculateValues(testVarCont1)

        testVec = testTerm%evaluate(testVarCont1)
        rateVec = -testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(1),tolerance=1.0d-14)
        end if  

        call initVariableBoltzmannStencilDirect(templateObj2,envObj,"f","f",testCRMData,1,1,.true.,.false.)

        call testTerm2%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj2,&
                           mbData=testCRMData)

        call testTerm2%update(testVarCont1,modelData=testCRMData)
        call testTerm2%calculateValues(testVarCont1)

        testVec = testTerm2%evaluate(testVarCont1)
        rateVec = testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(1),tolerance=1.0d-14)
        end if
        
        call initVariableBoltzmannStencilDirect(templateObj3,envObj,"f","f",testCRMData,1,2,.false.,.true.)

        call testTerm3%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj3,&
        mbData=testCRMData)

        call testTerm3%update(testVarCont1,modelData=testCRMData)
        call testTerm3%calculateValues(testVarCont1)

        testVec = testTerm3%evaluate(testVarCont1)
        rateVec = - testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(2),tolerance=1.0d-14)
        end if

        call initVariableBoltzmannStencilDirect(templateObj4,envObj,"f","f",testCRMData,1,2,.true.,.true.)

        call testTerm4%init(testGrid,testPart,testIndexing,testController%getWorldRank(),"f","f",testVarCont1,templateObj4,&
        mbData=testCRMData)

        call testTerm4%update(testVarCont1,modelData=testCRMData)
        call testTerm4%calculateValues(testVarCont1)

        testVec = testTerm4%evaluate(testVarCont1)
        rateVec = testVSpace%calculateMoment(testVec,1,0)

        if (testPart%getMinHAtInd(testController%getWorldRank()+1) == 1) then
            @assertEqual(rateVec(2:4),testCRMData%getTransitionRate(2),tolerance=1.0d-12)
        end if

    end subroutine test_var_boltz_stencil_template

    module function testCalculate(this,inputArray,indices) result(output)

        class(testDerivation)               ,intent(inout) :: this
        type(realArray)       ,dimension(:) ,intent(in) :: inputArray 
        integer(ik)           ,dimension(:) ,intent(in) :: indices
        real(rk) ,allocatable ,dimension(:)             :: output

        output = inputArray(indices(1))%entry 

    end function testCalculate

    module function testCalculate2(this,inputArray,indices) result(output)

        class(testDerivation2)               ,intent(inout) :: this
        type(realArray)       ,dimension(:) ,intent(in) :: inputArray 
        integer(ik)           ,dimension(:) ,intent(in) :: indices
        real(rk) ,allocatable ,dimension(:)             :: output

        allocate(output(10*size(inputArray(1)%entry)))
        output = real(1,kind=rk)

    end function testCalculate2

end module test_kinetic_models

